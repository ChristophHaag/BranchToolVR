<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>imebra: Getting started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">imebra
   &#160;<span id="projectnumber">2015 build 20160119-002</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Introduction</span></a></li>
      <li class="current"><a href="pages.html"><span>User&#160;manual</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('quick_tour.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Getting started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="quick_tour_project"></a>
Adding the Imebra library to your project</h1>
<p>You should read <a class="el" href="add_to_project.html">Adding Imebra to your project</a> to learn how to include Imebra to your project.</p>
<p>For the impatients:</p>
<ul>
<li>Add all the files in the directories library/base and library/imebra to your project</li>
<li>Disable the use of the precompiled header for all the Imebra source files (.cpp)</li>
<li>Include the file "library/imebra/include/imebra.h" in all the files that use the Imebra classes, or include it in the precompiled headers</li>
<li>If you are compiling the application on Windows, then define the preprocessor symbol PUNTOEXE_WINDOWS</li>
</ul>
<h1><a class="anchor" id="quick_tour_dataSet"></a>
Let's read a dataSet</h1>
<p>A dataSet can be created by reading a Dicom stream or a Jpeg stream; Imebra detects the stream format automatically.</p>
<p>The first operation to perform is the creation of a stream; this can be a file or a memory buffer.</p>
<p>In this example we use a file stream. The following code creates a file stream and open the file "d:\test.dcm" in read mode: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>puntoexe;</div>
<div class="line"><a class="code" href="classpuntoexe_1_1ptr.html">ptr&lt;stream&gt;</a> readStream(<span class="keyword">new</span> <a class="code" href="classpuntoexe_1_1stream.html">stream</a>);</div>
<div class="line">readStream-&gt;openFile(<span class="stringliteral">&quot;d:\\test.dcm&quot;</span>, std::ios::in);</div>
</div><!-- fragment --><p>In the previous code the application used a smart pointer (see <a class="el" href="classpuntoexe_1_1ptr.html" title="This class represents a shared pointer which keeps track of the allocated objects that derive from th...">puntoexe::ptr</a>) that tracks the usage of a stream object; when the smart pointer (the variable readStream) goes out of scope then the reference counter of the stream is decreased. Eventually the stream is deleted when the reference counter reaches 0.</p>
<p>With the following code we parse the content of the file managed by the stream and we create a dataSet structure that contains the dicom tags defined in the file. We create a streamReader object, which accesses the stream and gets data from it. Several streamReader objects can share a single baseStream, even in multithread environments. </p>
<div class="fragment"><div class="line">ptr&lt;streamReader&gt; reader(<span class="keyword">new</span> streamReader(readStream));</div>
<div class="line">ptr&lt;imebra::dataSet&gt; testDataSet = </div>
<div class="line">        imebra::codecs::codecFactory::getCodecFactory()-&gt;load(reader);</div>
</div><!-- fragment --><p>The previous code gets the pointer to the <a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1codec_factory.html">puntoexe::imebra::codecs::codecFactory</a>, which in turn loads the data from the specified stream. The codecs factory automatically detects the data format (dicom or jpeg). There is only one instance of the codec factory allocated by the library.</p>
<h1><a class="anchor" id="quick_tour_tag"></a>
Let's read or set a tag in the dataSet</h1>
<p>Once the dataSet has been created or loaded, your application can read or write values from/to the dataSet's tags.</p>
<p>In the following example we read the patient's name.</p>
<p>A person name can have up to 5 components (last name, middle name, first name,...) separated by ^ and can be represented in 3 different ways (character representation, ideographic representation or phonetic representation) separated by a =.</p>
<p>Refer to the Dicom standard for more informations regarding the person name.</p>
<p>The Person Name handler in Imebra automatically separates the name's representation, while the name's components have to be separated by the application. </p>
<div class="fragment"><div class="line">std::string patientNameCharacter = testDataSet-&gt;getString(0x0010, 0, 0x0010, 0);</div>
<div class="line">std::string patientNameIdeographic = testDataSet-&gt;getString(0x0010, 0, 0x0010, 1);</div>
</div><!-- fragment --><h1><a class="anchor" id="quick_tour_image"></a>
Let's read an image</h1>
<p>The dataSet provides two functions that can decompress an image embedded into a dataSet:</p>
<ul>
<li><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a67b350715dd0d0fb03922fcf89dcf8c8" title="Retrieve an image from the dataset. ">puntoexe::imebra::dataSet::getImage()</a></li>
<li><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aa9ea638e3dcd1ba46e9a75f2f82330c4" title="Retrieve an image from the dataset and apply the modality transform if it is specified in the dataset...">puntoexe::imebra::dataSet::getModalityImage()</a></li>
</ul>
<p><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a67b350715dd0d0fb03922fcf89dcf8c8" title="Retrieve an image from the dataset. ">puntoexe::imebra::dataSet::getImage()</a> retrieves the original images stored in the dataset, while <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aa9ea638e3dcd1ba46e9a75f2f82330c4" title="Retrieve an image from the dataset and apply the modality transform if it is specified in the dataset...">puntoexe::imebra::dataSet::getModalityImage()</a> retrieves the images after the modality VOI/LUT has been applied (if a modality VOI/LUT is available).</p>
<p>The following example reads the first image embedded into a dataSet: </p>
<div class="fragment"><div class="line">ptr&lt;imebra::image&gt; firstImage = testDataSet-&gt;getModalityImage(0);</div>
</div><!-- fragment --><p>Further processing may be required to convert firstImage into an image suitable for the presentation on the screen. The VOILUT transform applies the contrast suggested by the dataSet to the image. For instance: </p>
<div class="fragment"><div class="line">ptr&lt;imebra::transforms::transform&gt; myVoiLut(</div>
<div class="line">        <span class="keyword">new</span> imebra::transforms::VOILUT(testDataSet));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Apply the first VOI or LUT</span></div>
<div class="line">std::uint32_t lutId = myVoiLut-&gt;getVOILUTId(0);</div>
<div class="line">myVoiLut-&gt;setVOILUT(lutId);</div>
<div class="line"></div>
<div class="line">ptr&lt;imebra::image&gt; presentationImage(myVoiLut-&gt;allocateOutputImage(convertedImage, width, height));</div>
<div class="line">myVoiLut-&gt;runTransform(convertedImage, 0, 0 width, height, presentationImage, 0, 0);</div>
</div><!-- fragment --><p>And do you need the image in an RGB format? Here you go: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>puntoexe::imebra;</div>
<div class="line"><a class="code" href="classpuntoexe_1_1imebra_1_1transforms_1_1color_transforms_1_1color_transforms_factory.html">transforms::colorTransforms::colorTransformsFactory</a>* pFactory = <a class="code" href="classpuntoexe_1_1imebra_1_1transforms_1_1color_transforms_1_1color_transforms_factory.html#aa701c93b042bdcfb8ca4ca659125a193">transforms::colorTransforms::colorTransformsFactory::getColorTransformsFactory</a>();</div>
<div class="line"><a class="code" href="classpuntoexe_1_1ptr.html">ptr&lt;transforms::transform&gt;</a> myColorTransform = pFactory-&gt;getTransform(presentationImage-&gt;getColorSpace(), L<span class="stringliteral">&quot;RGB&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(myColorTransform != 0) <span class="comment">// color transform not needed if the factory returns 0</span></div>
<div class="line">{</div>
<div class="line">        <a class="code" href="classpuntoexe_1_1ptr.html">ptr&lt;image&gt;</a> rgbImage(myColorTransform-&gt;allocateOutputImage(presentationImage, width, height));</div>
<div class="line">        myColorTransform-&gt;runTransform(presentationImage, 0, 0, width, height, rgbImage, 0, 0);</div>
<div class="line">        presentationImage = rgbImage;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now the variable presentationImage contains an RGB image.</p>
<h1><a class="anchor" id="quick_tour_image_pixels"></a>
How to access the image's pixels</h1>
<p>In order to access to the image's pixels you have to retrieve a data handler: </p>
<div class="fragment"><div class="line">std::uint32_t rowSize, channelPixelSize, channelsNumber;</div>
<div class="line">ptr&lt;imebra::handlers::dataHandlerNumericBase&gt; myHandler = presentationImage-&gt;getDataHandler(<span class="keyword">false</span>, &amp;rowSize, &amp;channelPixelSize, &amp;channelsNumber);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Retrieve the image&#39;s size in pixels</span></div>
<div class="line">std::uint32_t sizeX, sizeY;</div>
<div class="line">presentationImage-&gt;getSize(&amp;sizeX, &amp;sizeY);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Scan all the rows</span></div>
<div class="line">std::uint32_t index(0);</div>
<div class="line"><span class="keywordflow">for</span>(std::uint32_t scanY = 0; scanY &lt; sizeY; ++scanY)</div>
<div class="line">{</div>
<div class="line">        <span class="comment">// Scan all the columns</span></div>
<div class="line">        <span class="keywordflow">for</span>(std::uint32_t scanX = 0; scanX &lt; sizeX; ++scanX)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// Scan all the channels</span></div>
<div class="line">                <span class="keywordflow">for</span>(std::uint32_t scanChannel = 0; scanChannel &lt; channelsNumber; ++scanChannel)</div>
<div class="line">                {</div>
<div class="line">            std::int32_t channelValue = myHandler-&gt;getSignedLong(index++);</div>
<div class="line">                        </div>
<div class="line">                        <span class="comment">// Do something with the channel&#39;s value</span></div>
<div class="line">                        <span class="comment">//--------------------------------------</span></div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The data handler provides also a pointer to the image's data, which allows to access the pixels' values in a faster way.<br/>
Use the method puntoexe::imebra::handlers::dataHandlerNumericBase::getMemoryBuffer() to retrieve a pointer to the first pixel channel. Note that the values may be 1, 2 or 4 bytes wide, signed or unsigned, according to the image's bit depth and signed/unsigned attribute. You can use the functions <a class="el" href="classpuntoexe_1_1imebra_1_1handlers_1_1data_handler.html#abb8cff8f9eb049843e7c337e3305471b" title="Returns a single element&#39;s size in bytes. ">puntoexe::imebra::handlers::dataHandler::getUnitSize()</a> and <a class="el" href="classpuntoexe_1_1imebra_1_1handlers_1_1data_handler_numeric_base.html#a2d62a38d9e60b948a780725aa7ade104" title="Returns truen if the buffer&#39;s elements are signed, false otherwise. ">puntoexe::imebra::handlers::dataHandlerNumericBase::isSigned()</a> to retrieve the values width in bytes and the signed/unsigned attribute.</p>
<div class="fragment"><div class="line">std::uint32_t rowSize, channelPixelSize, channelsNumber;</div>
<div class="line">ptr&lt;imebra::handlers::dataHandlerNumericBase&gt; myHandler = presentationImage-&gt;getDataHandler(<span class="keyword">false</span>, &amp;rowSize, &amp;channelPixelSize, &amp;channelsNumber);</div>
<div class="line">std::int32_t* pBuffer = myHandler-&gt;getMemoryBuffer();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Retrieve the image&#39;s size in pixels</span></div>
<div class="line">std::uint32_t sizeX, sizeY;</div>
<div class="line">presentationImage-&gt;getSize(&amp;sizeX, &amp;sizeY);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Scan all the rows. We assume that the pixels are 32 bits wide and signed</span></div>
<div class="line"><span class="keywordflow">if</span>(myHandler-&gt;getUnitSize() == <span class="keyword">sizeof</span>(std::int32_t) &amp;&amp; myHandler-&gt;isSigned())</div>
<div class="line">{</div>
<div class="line">        <span class="keywordflow">for</span>(std::uint32_t scanY = 0; scanY &lt; sizeY; ++scanY)</div>
<div class="line">        {</div>
<div class="line">        <span class="comment">// Scan all the columns</span></div>
<div class="line">        <span class="keywordflow">for</span>(std::uint32_t scanX = 0; scanX &lt; sizeX; ++scanX)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// Scan all the channels</span></div>
<div class="line">                <span class="keywordflow">for</span>(std::uint32_t scanChannel = 0; scanChannel &lt; channelsNumber; ++scanChannel)</div>
<div class="line">                {</div>
<div class="line">                        std::int32_t channelValue = *(pBuffer++);</div>
<div class="line">                        </div>
<div class="line">                        <span class="comment">// Do something with the channel&#39;s value</span></div>
<div class="line">                        <span class="comment">//--------------------------------------</span></div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="quick_tour_image_display"></a>
Displaying an image.</h1>
<p>The class <a class="el" href="classpuntoexe_1_1imebra_1_1draw_bitmap.html" title="This class takes an image as an input and returns an 8 bit RGB bitmap of the requested image&#39;s area...">puntoexe::imebra::drawBitmap</a> takes an image as an input and returns an 8 bit RGB bitmap of the requested image's area.</p>
<p>Each bitmap's row can be aligned to specific bytes boundaries and can store the pixels in the followig formats:</p>
<ul>
<li>puntoexe::imebra::drawBitmap::drawBitmapRGB: each pixel is formed by 3 bytes (R, G and B)</li>
<li>puntoexe::imebra::drawBitmap::drawBitmapBGR: each pixel is formed by (B, G and R). Suitable for Windows systems</li>
<li>puntoexe::imebra::drawBitmap::drawBitmapRGBA: each pixel is formed by 4 bytes (R, G, B and A). Suitable for Android &amp; Mac (OSX, iOS)</li>
<li>puntoexe::imebra::drawBitmap::drawBitmapBGRA: each pixel is formed by 4 bytes (B, G, R and A). Suitable for Windows systems</li>
</ul>
<p>drawBitmap takes care of converting the color format to RGB if necessary, and also shifts the values to obtain 8 bit per color component.</p>
<p>If you used <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aa9ea638e3dcd1ba46e9a75f2f82330c4" title="Retrieve an image from the dataset and apply the modality transform if it is specified in the dataset...">puntoexe::imebra::dataSet::getModalityImage()</a> to retrieve the image then the modality transform has already been applied to the image, otherwise it must be applied by your application (see <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1modality_v_o_i_l_u_t.html" title="This class transforms the pixel values of the image retrieved from the dataset into values that are m...">puntoexe::imebra::transforms::modalityVOILUT</a>) Sometimes the image must be processed with a presentation VOI/LUT transformations before it can be displayed.<br/>
A dataSet may contain several presentation VOI/LUTs and each one of them may highlight different parts of the image by applying different predefined contrasts or lookup tables.<br/>
The class <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1_v_o_i_l_u_t.html" title="Transforms the value of the input image&#39;s pixels by using the presentation VOI/LUT defined in the dat...">puntoexe::imebra::transforms::VOILUT</a> is responsible for retrieving the list of available presentation VOIs/LUTs, applying the selected VOI/LUT or finding the ideal LUT if none is specified in the dataSet.</p>
<p>The constructor of the <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1_v_o_i_l_u_t.html" title="Transforms the value of the input image&#39;s pixels by using the presentation VOI/LUT defined in the dat...">puntoexe::imebra::transforms::VOILUT</a> class takes a dataset as parameter in the constructor: then it uses the dataset to retrieve the available VOI or LUTs.</p>
<h2><a class="anchor" id="quick_tour_image_display_list_voilut"></a>
Listing the presentation VOIs/LUTs defined in the dataset</h2>
<p>The method <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1_v_o_i_l_u_t.html#a81899c846ee73d2ada193a33aafa8337" title="Return a list of ids of the VOIs and LUTs defined in the database. ">puntoexe::imebra::transforms::VOILUT::getVOILUTIds()</a> retrieves a list of IDs representing each VOI/LUT defined in the dataset.</p>
<p>Each ID may represent a VOI (Value of interest) or a LUT defined in the dataset: use <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1_v_o_i_l_u_t.html#a89f06a348d70f7ba88f455959a3d1d15" title="Return a description for the VOI or LUT with the specified ID. ">puntoexe::imebra::transforms::VOILUT::getVOILUTDescription()</a> to retrieve the description for a particular VOI or LUT.</p>
<div class="fragment"><div class="line"><span class="comment">// Construct a VOILUT from a dataset</span></div>
<div class="line"><span class="comment"></span>ptr&lt;imebra::transforms::VOILUT&gt; pVOILUT = <span class="keyword">new</span> imebra::transforms::VOILUT(testDataSet);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get the list of defined VOIs and LUTs</span></div>
<div class="line"><span class="comment"></span>imebra::transforms::VOILUT::voilutIds_t availableIds = pVOILUT-&gt;getVOILUTIds();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">\subsection quick_tour_image_display_select_voilut Selecting the presentation VOI/LUT</div>
<div class="line"></div>
<div class="line"><span class="comment">// Print out the description for the available VOI/LUTs</span></div>
<div class="line"><span class="comment"></span><span class="keywordflow">for</span>(imebra::transforms::VOILUT::voilutIds_t::iterator scan(availableIds.begin()), end(availableIds.end()); scan != end; ++scan)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; pVOILUT-&gt;getVOILUTDescription(*scan);</div>
<div class="line">}</div>
</div><!-- fragment --><p>To select the VOI or LUT to apply to the image, pass the proper VOILUT id to the method <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1_v_o_i_l_u_t.html#a9f7144b26aad01a52bb47b6652587749" title="Define the VOI/LUT to use for the transformation. ">puntoexe::imebra::transforms::VOILUT::setVOILUT()</a>.</p>
<div class="fragment"><div class="line">pVOILUT-&gt;setVOILUT(availableIds.front());</div>
</div><!-- fragment --><p>The application may also apply a VOI not defined in the dataset by using <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1_v_o_i_l_u_t.html#a096f217c2bfa496d9ee0ff5d9dd1f640" title="Define the VOI width/center to use for the transformation. ">puntoexe::imebra::transforms::VOILUT::setCenterWidth()</a> or <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1_v_o_i_l_u_t.html#af0050a981425b1df6d5350781f545dad" title="Finds and apply the optimal VOI values. ">puntoexe::imebra::transforms::VOILUT::applyOptimalVOI()</a> which analyzes the image and selects the proper VOI.</p>
<h2><a class="anchor" id="quick_tour_image_display_drawbitmap"></a>
Drawing the image</h2>
<p>After the VOI or LUT has been selected, pass the transform class to the drawBitmap constructor which will apply it to the input image before calculating the output bytes.</p>
<div class="fragment"><div class="line"><span class="comment">// Initialize the drawBitmap object</span></div>
<div class="line"><span class="comment"></span>ptr&lt;imebra::drawBitmap&gt; draw = <span class="keyword">new</span> imebra::drawBitmap(presentationImage, pVOILUT);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Fill the puntoexe::memory object with the image in RGBA format</span></div>
<div class="line"><span class="comment"></span>ptr&lt;memory&gt; memory = draw-&gt;getBitmap&lt;<a class="code" href="group__group__helpers.html#ggab9a086da1bbbbac2bdc3c59f8b4d51cea266c38e5071bd841662843823352e440">imebra::drawBitmap::drawBitmapRGBA</a>, 4&gt;</div>
<div class="line">                        (width, height, 0, 0, width, height, 0);</div>
<div class="line"></div>
<div class="line">std::uint8_t* pRawData = memory-&gt;data(); <span class="comment">// Data ready to be displayed in RGBA format</span></div>
</div><!-- fragment --><h2><a class="anchor" id="quick_tour_image_display_mac"></a>
Using drawBitmap on OS-X or iOS.</h2>
<p>Please read also the previous sections, since they contain important information relevant to understand this section.</p>
<p>A special helper method called <a class="el" href="group__group__objectivec.html#gaec161d99cc7fb7cec007330bdc698d10" title="Convert an Imebra image into an UIImage (on iOS) or NSImage (on OS-X) ready to be rendered...">getImage()</a> is available for OS-X and iOS (add the files in the folder objectivec to your project, see <a class="el" href="add_to_project.html#add_to_project_files_mac">OS-X/iOS specific: Adding the source files to your project</a>).</p>
<p>This method uses <a class="el" href="classpuntoexe_1_1imebra_1_1draw_bitmap.html" title="This class takes an image as an input and returns an 8 bit RGB bitmap of the requested image&#39;s area...">puntoexe::imebra::drawBitmap</a> to produce an UIImage or NSImage that can be used directly.</p>
<p>The method accepts the same parameters as drawBitmap's constructor but instead of a raw buffer it returns an UIImage or NSImage object that can be used directly by your application. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jan 19 2016 15:32:15 for imebra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
