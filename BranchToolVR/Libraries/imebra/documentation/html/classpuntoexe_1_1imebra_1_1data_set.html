<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>imebra: puntoexe::imebra::dataSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">imebra
   &#160;<span id="projectnumber">2015 build 20160119-002</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Introduction</span></a></li>
      <li><a href="pages.html"><span>User&#160;manual</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classpuntoexe_1_1imebra_1_1data_set.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classpuntoexe_1_1imebra_1_1data_set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">puntoexe::imebra::dataSet Class Reference<div class="ingroups"><a class="el" href="group__group__dataset.html">Dicom data</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A data set is a collection of groups of tags (see <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html" title="Represents a Dicom group which stores a group of Dicom tags. ">dataGroup</a>). </p>
<p>The <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a> is usually built from a dicom stream by using the codec <a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1dicom_codec.html" title="The Dicom codec. ">codecs::dicomCodec</a>.</p>
<p>Also the tags with the data type SQ (sequence) contains one or more embedded dataSets that can be retrieved by using <a class="el" href="classpuntoexe_1_1imebra_1_1data.html#a5aa5b046862ea70323113a8822161d80" title="Retrieve an embedded data set. ">data::getDataSet()</a>.</p>
<p>If your application creates a new dataset then it can set the default <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a>'s charset by calling <a class="el" href="classpuntoexe_1_1imebra_1_1data_collection.html#a34e13cd4355bd3a3a0dd142dc9e51c79" title="Set the charsets used in the collection. ">setCharsetsList()</a>. See <a class="el" href="imebra_unicode.html">Imebra &amp; Unicode</a> for more information related to Imebra and the Dicom charsets.</p>
<p>The <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a> and its components (all the <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html" title="Represents a Dicom group which stores a group of Dicom tags. ">dataGroup</a>, and data) share a common lock object: this means that a lock on one of the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a>'s component will lock the entire <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a> and all its components.</p>
<p>For an introduction to the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a>, read <a class="el" href="quick_tour.html#quick_tour_dataSet">Let's read a dataSet</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="change_transfer_syntax_2change_transfer_syntax_8cpp-example.html#_a7">changeTransferSyntax/changeTransferSyntax.cpp</a>.</dd>
</dl></div>
<p><code>#include &lt;dataSet.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for puntoexe::imebra::dataSet:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpuntoexe_1_1imebra_1_1data_set.png" usemap="#puntoexe::imebra::dataSet_map" alt=""/>
  <map id="puntoexe::imebra::dataSet_map" name="puntoexe::imebra::dataSet_map">
<area href="classpuntoexe_1_1imebra_1_1data_collection.html" alt="puntoexe::imebra::dataCollection&lt; dataGroup &gt;" shape="rect" coords="0,56,276,80"/>
<area href="classpuntoexe_1_1base_object.html" title="This is the base class of the library. Almost all the classes in the library are derived from this on..." alt="puntoexe::baseObject" shape="rect" coords="0,0,276,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Get/set groups/tags</div></td></tr>
<tr class="memitem:a46ebeb89a79313fb0969ea0b7ffdff5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data.html">data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a46ebeb89a79313fb0969ea0b7ffdff5f">getTag</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, bool bCreate=false)</td></tr>
<tr class="memdesc:a46ebeb89a79313fb0969ea0b7ffdff5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag object.  <a href="#a46ebeb89a79313fb0969ea0b7ffdff5f">More...</a><br/></td></tr>
<tr class="separator:a46ebeb89a79313fb0969ea0b7ffdff5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade0dad9ea4df64c7429784fa458b956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aade0dad9ea4df64c7429784fa458b956">getGroup</a> (std::uint16_t groupId, std::uint16_t order, bool bCreate=false)</td></tr>
<tr class="memdesc:aade0dad9ea4df64c7429784fa458b956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a group object.  <a href="#aade0dad9ea4df64c7429784fa458b956">More...</a><br/></td></tr>
<tr class="separator:aade0dad9ea4df64c7429784fa458b956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca6bf2aeafd6742dff8a928ab77de9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aaca6bf2aeafd6742dff8a928ab77de9d">setGroup</a> (std::uint16_t groupId, std::uint16_t order, <a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> &gt; pGroup)</td></tr>
<tr class="memdesc:aaca6bf2aeafd6742dff8a928ab77de9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the specified group into the dataset.  <a href="#aaca6bf2aeafd6742dff8a928ab77de9d">More...</a><br/></td></tr>
<tr class="separator:aaca6bf2aeafd6742dff8a928ab77de9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get/set the image</div></td></tr>
<tr class="memitem:a67b350715dd0d0fb03922fcf89dcf8c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1image.html">image</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a67b350715dd0d0fb03922fcf89dcf8c8">getImage</a> (std::uint32_t frameNumber)</td></tr>
<tr class="memdesc:a67b350715dd0d0fb03922fcf89dcf8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an image from the dataset.  <a href="#a67b350715dd0d0fb03922fcf89dcf8c8">More...</a><br/></td></tr>
<tr class="separator:a67b350715dd0d0fb03922fcf89dcf8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ea638e3dcd1ba46e9a75f2f82330c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1image.html">image</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aa9ea638e3dcd1ba46e9a75f2f82330c4">getModalityImage</a> (std::uint32_t frameNumber)</td></tr>
<tr class="memdesc:aa9ea638e3dcd1ba46e9a75f2f82330c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an image from the dataset and apply the modality transform if it is specified in the dataset.  <a href="#aa9ea638e3dcd1ba46e9a75f2f82330c4">More...</a><br/></td></tr>
<tr class="separator:aa9ea638e3dcd1ba46e9a75f2f82330c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219ab785fe7a3abaf172f7190d717e29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a219ab785fe7a3abaf172f7190d717e29">setImage</a> (std::uint32_t frameNumber, <a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1image.html">image</a> &gt; pImage, std::wstring transferSyntax, <a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1codec.html#a2049bc83bc9c0c3345206bf34d4a3be9">codecs::codec::quality</a> quality)</td></tr>
<tr class="memdesc:a219ab785fe7a3abaf172f7190d717e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an image into the data set.  <a href="#a219ab785fe7a3abaf172f7190d717e29">More...</a><br/></td></tr>
<tr class="separator:a219ab785fe7a3abaf172f7190d717e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5265c23a33ec485e72fd4ce71a2e123f"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a5265c23a33ec485e72fd4ce71a2e123f">getFrameOffset</a> (std::uint32_t frameNumber)</td></tr>
<tr class="memdesc:a5265c23a33ec485e72fd4ce71a2e123f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a frame's offset from the offset table.  <a href="#a5265c23a33ec485e72fd4ce71a2e123f">More...</a><br/></td></tr>
<tr class="separator:a5265c23a33ec485e72fd4ce71a2e123f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d8d70fdd8f244328eece02e2215bb7"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#ae9d8d70fdd8f244328eece02e2215bb7">getFrameBufferId</a> (std::uint32_t offset, std::uint32_t *pLengthToBuffer)</td></tr>
<tr class="memdesc:ae9d8d70fdd8f244328eece02e2215bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the buffer that starts at the specified offset.  <a href="#ae9d8d70fdd8f244328eece02e2215bb7">More...</a><br/></td></tr>
<tr class="separator:ae9d8d70fdd8f244328eece02e2215bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad908b98caf72337c53c2d79821feb5d6"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#ad908b98caf72337c53c2d79821feb5d6">getFrameBufferIds</a> (std::uint32_t frameNumber, std::uint32_t *pFirstBuffer, std::uint32_t *pEndBuffer)</td></tr>
<tr class="memdesc:ad908b98caf72337c53c2d79821feb5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first and the last buffers used to store the image.  <a href="#ad908b98caf72337c53c2d79821feb5d6">More...</a><br/></td></tr>
<tr class="separator:ad908b98caf72337c53c2d79821feb5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66bb077e2e1b03a5095df49af69e178"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#ae66bb077e2e1b03a5095df49af69e178">getFirstAvailFrameBufferId</a> ()</td></tr>
<tr class="memdesc:ae66bb077e2e1b03a5095df49af69e178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first buffer's id available where a new frame can be saved.  <a href="#ae66bb077e2e1b03a5095df49af69e178">More...</a><br/></td></tr>
<tr class="separator:ae66bb077e2e1b03a5095df49af69e178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get/set a sequence item</div></td></tr>
<tr class="memitem:ae28244ca8a0c3c66acd8dcaa135198f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html">dataSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#ae28244ca8a0c3c66acd8dcaa135198f5">getSequenceItem</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t itemId)</td></tr>
<tr class="memdesc:ae28244ca8a0c3c66acd8dcaa135198f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a data set embedded into a sequence tag.  <a href="#ae28244ca8a0c3c66acd8dcaa135198f5">More...</a><br/></td></tr>
<tr class="separator:ae28244ca8a0c3c66acd8dcaa135198f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05706f9564bdb500a405631a5623b62b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1lut.html">lut</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a05706f9564bdb500a405631a5623b62b">getLut</a> (std::uint16_t groupId, std::uint16_t tagId, std::uint32_t lutId)</td></tr>
<tr class="memdesc:a05706f9564bdb500a405631a5623b62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a LUT.  <a href="#a05706f9564bdb500a405631a5623b62b">More...</a><br/></td></tr>
<tr class="separator:a05706f9564bdb500a405631a5623b62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a31cd71ac089418fcc7bc726c96088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1waveform.html">waveform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aa3a31cd71ac089418fcc7bc726c96088">getWaveform</a> (std::uint32_t waveformId)</td></tr>
<tr class="memdesc:aa3a31cd71ac089418fcc7bc726c96088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a waveform from the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a>.  <a href="#aa3a31cd71ac089418fcc7bc726c96088">More...</a><br/></td></tr>
<tr class="separator:aa3a31cd71ac089418fcc7bc726c96088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get/set the tags' values</div></td></tr>
<tr class="memitem:a57b6f1f619919428dbc8882bc5c15b94"><td class="memItemLeft" align="right" valign="top">std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a57b6f1f619919428dbc8882bc5c15b94">getSignedLong</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t elementNumber)</td></tr>
<tr class="memdesc:a57b6f1f619919428dbc8882bc5c15b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of the requested tag and return it as a signed long.  <a href="#a57b6f1f619919428dbc8882bc5c15b94">More...</a><br/></td></tr>
<tr class="separator:a57b6f1f619919428dbc8882bc5c15b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aa341f4e58f5328f3eede5c410afac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a03aa341f4e58f5328f3eede5c410afac">setSignedLong</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t elementNumber, std::int32_t newValue, std::string defaultType=&quot;&quot;)</td></tr>
<tr class="memdesc:a03aa341f4e58f5328f3eede5c410afac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tag's value as a signed long.  <a href="#a03aa341f4e58f5328f3eede5c410afac">More...</a><br/></td></tr>
<tr class="separator:a03aa341f4e58f5328f3eede5c410afac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cfffce28b7b1bf910361baee5f4c95"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#aa2cfffce28b7b1bf910361baee5f4c95">getUnsignedLong</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t elementNumber)</td></tr>
<tr class="memdesc:aa2cfffce28b7b1bf910361baee5f4c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag's value as an unsigned long.  <a href="#aa2cfffce28b7b1bf910361baee5f4c95">More...</a><br/></td></tr>
<tr class="separator:aa2cfffce28b7b1bf910361baee5f4c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340038e2662a3ac7a71c01df32d7a297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a340038e2662a3ac7a71c01df32d7a297">setUnsignedLong</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t elementNumber, std::uint32_t newValue, std::string defaultType=&quot;&quot;)</td></tr>
<tr class="memdesc:a340038e2662a3ac7a71c01df32d7a297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tag's value as an unsigned long.  <a href="#a340038e2662a3ac7a71c01df32d7a297">More...</a><br/></td></tr>
<tr class="separator:a340038e2662a3ac7a71c01df32d7a297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b420364d02a00a6b4011d8d4f8c9ca9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a4b420364d02a00a6b4011d8d4f8c9ca9">getDouble</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t elementNumber)</td></tr>
<tr class="memdesc:a4b420364d02a00a6b4011d8d4f8c9ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag's value as a double.  <a href="#a4b420364d02a00a6b4011d8d4f8c9ca9">More...</a><br/></td></tr>
<tr class="separator:a4b420364d02a00a6b4011d8d4f8c9ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb5feb4adb5211654b32de4d7b54e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a5cb5feb4adb5211654b32de4d7b54e91">setDouble</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t elementNumber, double newValue, std::string defaultType=&quot;&quot;)</td></tr>
<tr class="memdesc:a5cb5feb4adb5211654b32de4d7b54e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tag's value as a double.  <a href="#a5cb5feb4adb5211654b32de4d7b54e91">More...</a><br/></td></tr>
<tr class="separator:a5cb5feb4adb5211654b32de4d7b54e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a19c209f8187e01b67a4921b381988"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a22a19c209f8187e01b67a4921b381988">getString</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t elementNumber)</td></tr>
<tr class="memdesc:a22a19c209f8187e01b67a4921b381988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag's value as a string. <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a6a2a5ebf83ff8b350c87b1a0c732d2d6" title="Retrieve a tag&#39;s value as an unicode string. ">getUnicodeString()</a> is preferred over this method.  <a href="#a22a19c209f8187e01b67a4921b381988">More...</a><br/></td></tr>
<tr class="separator:a22a19c209f8187e01b67a4921b381988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2a5ebf83ff8b350c87b1a0c732d2d6"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a6a2a5ebf83ff8b350c87b1a0c732d2d6">getUnicodeString</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t elementNumber)</td></tr>
<tr class="memdesc:a6a2a5ebf83ff8b350c87b1a0c732d2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a tag's value as an unicode string.  <a href="#a6a2a5ebf83ff8b350c87b1a0c732d2d6">More...</a><br/></td></tr>
<tr class="separator:a6a2a5ebf83ff8b350c87b1a0c732d2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d555dd2c2873cdd20f8ae295c52bce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a3d555dd2c2873cdd20f8ae295c52bce1">setString</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t elementNumber, std::string newString, std::string defaultType=&quot;&quot;)</td></tr>
<tr class="memdesc:a3d555dd2c2873cdd20f8ae295c52bce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tag's value as a string. <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#ad6cd9796953fdd8afb1fcca724c922b3" title="Set a tag&#39;s value as an unicode string. ">setUnicodeString()</a> is preferred over this method.  <a href="#a3d555dd2c2873cdd20f8ae295c52bce1">More...</a><br/></td></tr>
<tr class="separator:a3d555dd2c2873cdd20f8ae295c52bce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cd9796953fdd8afb1fcca724c922b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#ad6cd9796953fdd8afb1fcca724c922b3">setUnicodeString</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t elementNumber, std::wstring newString, std::string defaultType=&quot;&quot;)</td></tr>
<tr class="memdesc:ad6cd9796953fdd8afb1fcca724c922b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a tag's value as an unicode string.  <a href="#ad6cd9796953fdd8afb1fcca724c922b3">More...</a><br/></td></tr>
<tr class="separator:ad6cd9796953fdd8afb1fcca724c922b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data handlers</div></td></tr>
<tr class="memitem:a274975395982ed9762f4085221789c7b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a274975395982ed9762f4085221789c7b">getDefaultDataType</a> (std::uint16_t groupId, std::uint16_t tagId)</td></tr>
<tr class="memdesc:a274975395982ed9762f4085221789c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default data type for the specified tag's id.  <a href="#a274975395982ed9762f4085221789c7b">More...</a><br/></td></tr>
<tr class="separator:a274975395982ed9762f4085221789c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8c3a1a5df658e8f41ca66347303342"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a6a8c3a1a5df658e8f41ca66347303342">getDataType</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId)</td></tr>
<tr class="memdesc:a6a8c3a1a5df658e8f41ca66347303342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data type of a tag.  <a href="#a6a8c3a1a5df658e8f41ca66347303342">More...</a><br/></td></tr>
<tr class="separator:a6a8c3a1a5df658e8f41ca66347303342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f0c1adba17bf4305335395f3e40e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1handlers_1_1data_handler.html">handlers::dataHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a78f0c1adba17bf4305335395f3e40e82">getDataHandler</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t bufferId, bool bWrite, std::string defaultType=&quot;&quot;)</td></tr>
<tr class="memdesc:a78f0c1adba17bf4305335395f3e40e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a data handler for the specified tag's buffer.  <a href="#a78f0c1adba17bf4305335395f3e40e82">More...</a><br/></td></tr>
<tr class="separator:a78f0c1adba17bf4305335395f3e40e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a21619559928f80b95c954dbb850c04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1handlers_1_1data_handler_raw.html">handlers::dataHandlerRaw</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a9a21619559928f80b95c954dbb850c04">getDataHandlerRaw</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t bufferId, bool bWrite, std::string defaultType=&quot;&quot;)</td></tr>
<tr class="memdesc:a9a21619559928f80b95c954dbb850c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a raw data handler for the specified tag's buffer.  <a href="#a9a21619559928f80b95c954dbb850c04">More...</a><br/></td></tr>
<tr class="separator:a9a21619559928f80b95c954dbb850c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d79f69919fb5b9e7aa754d266e6902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1stream_reader.html">streamReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a98d79f69919fb5b9e7aa754d266e6902">getStreamReader</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t bufferId)</td></tr>
<tr class="memdesc:a98d79f69919fb5b9e7aa754d266e6902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classpuntoexe_1_1stream_reader.html" title="Represents a stream reader. A stream reader can read data from a stream. Several stream readers can s...">streamReader</a> connected to the specified tag's buffer's memory.  <a href="#a98d79f69919fb5b9e7aa754d266e6902">More...</a><br/></td></tr>
<tr class="separator:a98d79f69919fb5b9e7aa754d266e6902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af749aa13e7df06e332b34be2661fd37c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1stream_writer.html">streamWriter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#af749aa13e7df06e332b34be2661fd37c">getStreamWriter</a> (std::uint16_t groupId, std::uint16_t order, std::uint16_t tagId, std::uint32_t bufferId, std::string dataType=&quot;&quot;)</td></tr>
<tr class="memdesc:af749aa13e7df06e332b34be2661fd37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classpuntoexe_1_1stream_writer.html" title="Use this class to write into a baseStream derived class. ">streamWriter</a> connected to the specified tag's buffer's memory.  <a href="#af749aa13e7df06e332b34be2661fd37c">More...</a><br/></td></tr>
<tr class="separator:af749aa13e7df06e332b34be2661fd37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Syncronize the charset tag (0008,0005)</div></td></tr>
<tr class="memitem:ae2691c6449b03aa9d7098ae92206cfc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#ae2691c6449b03aa9d7098ae92206cfc6">updateCharsetTag</a> ()</td></tr>
<tr class="memdesc:ae2691c6449b03aa9d7098ae92206cfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all the charsets used in the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a>'s tags and then update the content of the tag 0008,0005.  <a href="#ae2691c6449b03aa9d7098ae92206cfc6">More...</a><br/></td></tr>
<tr class="separator:ae2691c6449b03aa9d7098ae92206cfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206defbf8d6e74c6de6d628143b847c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a206defbf8d6e74c6de6d628143b847c2">updateTagsCharset</a> ()</td></tr>
<tr class="memdesc:a206defbf8d6e74c6de6d628143b847c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a>'s tags with the charsets specified in the tag 0008,0005.  <a href="#a206defbf8d6e74c6de6d628143b847c2">More...</a><br/></td></tr>
<tr class="separator:a206defbf8d6e74c6de6d628143b847c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set/get the item offset.</div></td></tr>
<tr class="memitem:ac4aa4e300d8f39542390d19c79f6e454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#ac4aa4e300d8f39542390d19c79f6e454">setItemOffset</a> (std::uint32_t offset)</td></tr>
<tr class="memdesc:ac4aa4e300d8f39542390d19c79f6e454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1dicom_codec.html" title="The Dicom codec. ">codecs::dicomCodec</a> when the dataset is written into a stream. Tells the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a> the position at which it has been written into the stream.  <a href="#ac4aa4e300d8f39542390d19c79f6e454">More...</a><br/></td></tr>
<tr class="separator:ac4aa4e300d8f39542390d19c79f6e454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbbd40d6cc3b66cac6c7e4eba57caca"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#abcbbd40d6cc3b66cac6c7e4eba57caca">getItemOffset</a> ()</td></tr>
<tr class="memdesc:abcbbd40d6cc3b66cac6c7e4eba57caca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the offset at which the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a> is located in the dicom stream.  <a href="#abcbbd40d6cc3b66cac6c7e4eba57caca">More...</a><br/></td></tr>
<tr class="separator:abcbbd40d6cc3b66cac6c7e4eba57caca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpuntoexe_1_1imebra_1_1data_collection"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpuntoexe_1_1imebra_1_1data_collection')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpuntoexe_1_1imebra_1_1data_collection.html">puntoexe::imebra::dataCollection&lt; dataGroup &gt;</a></td></tr>
<tr class="memitem:a34e13cd4355bd3a3a0dd142dc9e51c79 inherit pub_methods_classpuntoexe_1_1imebra_1_1data_collection"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_collection.html#a34e13cd4355bd3a3a0dd142dc9e51c79">setCharsetsList</a> (<a class="el" href="group__group__dataset.html#gabdae3bfebe84127bfda27b5df4db2f20">charsetsList::tCharsetsList</a> *pCharsetsList)</td></tr>
<tr class="memdesc:a34e13cd4355bd3a3a0dd142dc9e51c79 inherit pub_methods_classpuntoexe_1_1imebra_1_1data_collection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the charsets used in the collection.  <a href="#a34e13cd4355bd3a3a0dd142dc9e51c79">More...</a><br/></td></tr>
<tr class="separator:a34e13cd4355bd3a3a0dd142dc9e51c79 inherit pub_methods_classpuntoexe_1_1imebra_1_1data_collection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3053b8aa90c85a698215c5d733b437d inherit pub_methods_classpuntoexe_1_1imebra_1_1data_collection"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_collection_iterator.html">dataCollectionIterator</a><br class="typebreak"/>
&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1imebra_1_1data_collection.html#ad3053b8aa90c85a698215c5d733b437d">getDataIterator</a> ()</td></tr>
<tr class="memdesc:ad3053b8aa90c85a698215c5d733b437d inherit pub_methods_classpuntoexe_1_1imebra_1_1data_collection"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing to the first tag or group (data or dataGroup) in the collection.  <a href="#ad3053b8aa90c85a698215c5d733b437d">More...</a><br/></td></tr>
<tr class="separator:ad3053b8aa90c85a698215c5d733b437d inherit pub_methods_classpuntoexe_1_1imebra_1_1data_collection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpuntoexe_1_1base_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpuntoexe_1_1base_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpuntoexe_1_1base_object.html">puntoexe::baseObject</a></td></tr>
<tr class="memitem:a90f18188aff8fed694f5d590eb060c69 inherit pub_methods_classpuntoexe_1_1base_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1base_object.html#a90f18188aff8fed694f5d590eb060c69">baseObject</a> ()</td></tr>
<tr class="memdesc:a90f18188aff8fed694f5d590eb060c69 inherit pub_methods_classpuntoexe_1_1base_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="classpuntoexe_1_1base_object.html" title="This is the base class of the library. Almost all the classes in the library are derived from this on...">baseObject</a> object. The reference counter is set to 0.  <a href="#a90f18188aff8fed694f5d590eb060c69">More...</a><br/></td></tr>
<tr class="separator:a90f18188aff8fed694f5d590eb060c69 inherit pub_methods_classpuntoexe_1_1base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8274383364600b41e4345646bad8a01d inherit pub_methods_classpuntoexe_1_1base_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1base_object.html#a8274383364600b41e4345646bad8a01d">baseObject</a> (const <a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1base_object.html">baseObject</a> &gt; &amp;externalLock)</td></tr>
<tr class="memdesc:a8274383364600b41e4345646bad8a01d inherit pub_methods_classpuntoexe_1_1base_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="classpuntoexe_1_1base_object.html" title="This is the base class of the library. Almost all the classes in the library are derived from this on...">baseObject</a> object and set an external object to be used for the lock. The reference counter is set to 0.  <a href="#a8274383364600b41e4345646bad8a01d">More...</a><br/></td></tr>
<tr class="separator:a8274383364600b41e4345646bad8a01d inherit pub_methods_classpuntoexe_1_1base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a63a2a0128a08419e8862278b01e9e inherit pub_methods_classpuntoexe_1_1base_object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpuntoexe_1_1base_object.html#a09a63a2a0128a08419e8862278b01e9e">isReferencedOnce</a> ()</td></tr>
<tr class="memdesc:a09a63a2a0128a08419e8862278b01e9e inherit pub_methods_classpuntoexe_1_1base_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one if the reference count is set to 1.  <a href="#a09a63a2a0128a08419e8862278b01e9e">More...</a><br/></td></tr>
<tr class="separator:a09a63a2a0128a08419e8862278b01e9e inherit pub_methods_classpuntoexe_1_1base_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a78f0c1adba17bf4305335395f3e40e82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1handlers_1_1data_handler.html">handlers::dataHandler</a> &gt; puntoexe::imebra::dataSet::getDataHandler </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>bufferId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a data handler for the specified tag's buffer. </p>
<p>The data handler allows the application to read, write and resize the tag's buffer.</p>
<p>A tag can store several buffers, then the application must specify the buffer's id it wants to deal with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>the group to which the tag belongs </td></tr>
    <tr><td class="paramname">order</td><td>if the group is recurring in the file (it appears several times), then use this parameter to specify to which group the tag belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>the tag's id </td></tr>
    <tr><td class="paramname">bufferId</td><td>the buffer's id (zero based) </td></tr>
    <tr><td class="paramname">bWrite</td><td>true if the application wants to write into the buffer </td></tr>
    <tr><td class="paramname">defaultType</td><td>a string with the dicom data type to use if the buffer doesn't exist. If none is specified, then a default data type will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the data handler. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dicomdir_items_2dicomdir_items_8cpp-example.html#a1">dicomdirItems/dicomdirItems.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9a21619559928f80b95c954dbb850c04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1handlers_1_1data_handler_raw.html">handlers::dataHandlerRaw</a> &gt; puntoexe::imebra::dataSet::getDataHandlerRaw </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>bufferId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a raw data handler for the specified tag's buffer. </p>
<p>A raw data handler always sees the buffer as a collection of bytes, no matter what the tag's data type is.</p>
<p>A tag can store several buffers, then the application must specify the buffer's id it wants to deal with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>the group to which the tag belongs </td></tr>
    <tr><td class="paramname">order</td><td>if the group is recurring in the file (it appears several times), then use this parameter to specify to which group the tag belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>the tag's id </td></tr>
    <tr><td class="paramname">bufferId</td><td>the buffer's id (zero based) </td></tr>
    <tr><td class="paramname">bWrite</td><td>true if the application wants to write into the buffer </td></tr>
    <tr><td class="paramname">defaultType</td><td>a string with the dicom data type to use if the buffer doesn't exist. If none is specified, then a default data type will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the data handler. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a8c3a1a5df658e8f41ca66347303342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string puntoexe::imebra::dataSet::getDataType </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the data type of a tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag belongs </td></tr>
    <tr><td class="paramname">order</td><td>When multiple groups with the same it are present, then use this parameter to specify which group must be used. The first group as an order of 0. </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag for which the type must be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the tag's type. </dd></dl>

</div>
</div>
<a class="anchor" id="a274975395982ed9762f4085221789c7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string puntoexe::imebra::dataSet::getDefaultDataType </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the default data type for the specified tag's id. </p>
<p>The default data type is retrieved from an internal dictionary which stores the default properties of each dicom's tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag belongs </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tag's default type. The returned string is a constant. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b420364d02a00a6b4011d8d4f8c9ca9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double puntoexe::imebra::dataSet::getDouble </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>elementNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a tag's value as a double. </p>
<p>Read the value of the requested tag and return it as a double.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be read belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to retrieve. A buffer can store several elements: this parameter specifies which element must be retrieved. The first element's number is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag's content, as a double </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dicom2jpeg_2dicom2jpeg_8cpp-example.html#a33">dicom2jpeg/dicom2jpeg.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae66bb077e2e1b03a5095df49af69e178"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t puntoexe::imebra::dataSet::getFirstAvailFrameBufferId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first buffer's id available where a new frame can be saved. </p>
<dl class="section return"><dt>Returns</dt><dd>the id of the first buffer available to store a new frame </dd></dl>

</div>
</div>
<a class="anchor" id="ae9d8d70fdd8f244328eece02e2215bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t puntoexe::imebra::dataSet::getFrameBufferId </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t *&#160;</td>
          <td class="paramname"><em>pLengthToBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the id of the buffer that starts at the specified offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>one offset retrieved from the frames offset table: see <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a5265c23a33ec485e72fd4ce71a2e123f" title="Get a frame&#39;s offset from the offset table. ">getFrameOffset()</a> </td></tr>
    <tr><td class="paramname">pLengthToBuffer</td><td>a pointer to a variable that will store the total lenght of the buffers that preceed the one being returned (doesn't include the tag descriptors) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the buffer that starts at the specified offset </dd></dl>

</div>
</div>
<a class="anchor" id="ad908b98caf72337c53c2d79821feb5d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t puntoexe::imebra::dataSet::getFrameBufferIds </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>frameNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t *&#160;</td>
          <td class="paramname"><em>pFirstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t *&#160;</td>
          <td class="paramname"><em>pEndBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the first and the last buffers used to store the image. </p>
<p>This function works only with the new Dicom3 streams, not with the old NEMA format.</p>
<p>This function is used by <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a219ab785fe7a3abaf172f7190d717e29" title="Insert an image into the data set. ">setImage()</a> and <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a67b350715dd0d0fb03922fcf89dcf8c8" title="Retrieve an image from the dataset. ">getImage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameNumber</td><td>the frame for which the buffers have to be retrieved </td></tr>
    <tr><td class="paramname">pFirstBuffer</td><td>a pointer to a variable that will contain the id of the first buffer used to store the image </td></tr>
    <tr><td class="paramname">pEndBuffer</td><td>a pointer to a variable that will contain the id of the first buffer next to the last one used to store the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total length of the buffers that contain the image </dd></dl>

</div>
</div>
<a class="anchor" id="a5265c23a33ec485e72fd4ce71a2e123f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t puntoexe::imebra::dataSet::getFrameOffset </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>frameNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a frame's offset from the offset table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameNumber</td><td>the number of the frame for which the offset is requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the offset for the specified frame </dd></dl>

</div>
</div>
<a class="anchor" id="aade0dad9ea4df64c7429784fa458b956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> &gt; puntoexe::imebra::dataSet::getGroup </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCreate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a group object. </p>
<p>A Group object is represented by the <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> class.</p>
<p>If the group doesn't exist and the parameter bCreate is set to false, then the function returns a null pointer. If the group doesn't exist and the parameter bCreate is set to true, then an empty group will be created and inserted into the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to retrieve. </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify which group must be retrieved. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero. </td></tr>
    <tr><td class="paramname">bCreate</td><td>When bCreate is set to true and the requested group doesn't exist, then a new one is created and inserted into the dataset. When bCreate is set to false and the requested group doesn't exist, then a null pointer is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the retrieved group. The group should be released as soon as possible using the function Release(). If the requested group doesn't exist then the returned value depend on the value of the bCreate parameter: when bCreate is false then a value of zero is returned, otherwise a pointer to the just created group is returned. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="change_transfer_syntax_2change_transfer_syntax_8cpp-example.html#a5">changeTransferSyntax/changeTransferSyntax.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a67b350715dd0d0fb03922fcf89dcf8c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1image.html">image</a> &gt; puntoexe::imebra::dataSet::getImage </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>frameNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an image from the dataset. </p>
<p>The right codec will be automatically used to decode the image embedded into the dataset. If multiple frames are available, then the calling application can decide the frame to retrieve.</p>
<p>The function throw an exception if the requested image doesn't exist or the image's tag is corrupted.</p>
<p>The retrieved image should then be processed by the <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1modality_v_o_i_l_u_t.html" title="This class transforms the pixel values of the image retrieved from the dataset into values that are m...">transforms::modalityVOILUT</a> transform in order to convert the pixels value to a meaningful space. Infact, the dicom image's pixel values saved by other application have a meaningful value only for the application that generated them, while the modality VOI/LUT transformation will convert those values to a more portable unit (e.g.: optical density).</p>
<p>Further transformations are applied by the <a class="el" href="classpuntoexe_1_1imebra_1_1transforms_1_1_v_o_i_l_u_t.html" title="Transforms the value of the input image&#39;s pixels by using the presentation VOI/LUT defined in the dat...">transforms::VOILUT</a> transform, in order to adjust the image's contrast for displaying purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameNumber</td><td>The frame number to retrieve. The first frame's id is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the retrieved image </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="change_transfer_syntax_2change_transfer_syntax_8cpp-example.html#a14">changeTransferSyntax/changeTransferSyntax.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="abcbbd40d6cc3b66cac6c7e4eba57caca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t puntoexe::imebra::dataSet::getItemOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the offset at which the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a> is located in the dicom stream. </p>
<dl class="section return"><dt>Returns</dt><dd>the position at which the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a> is located in the dicom stream </dd></dl>

</div>
</div>
<a class="anchor" id="a05706f9564bdb500a405631a5623b62b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1lut.html">lut</a> &gt; puntoexe::imebra::dataSet::getLut </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>lutId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a LUT. </p>
<p>LUT are encoded into sequences. This function retrieve the sequence and build a <a class="el" href="classpuntoexe_1_1imebra_1_1lut.html">lut</a> object describing the LUT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the LUT sequence belongs </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to containing the LUT </td></tr>
    <tr><td class="paramname">lutId</td><td>The id of the lut inside the tag (0 based) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the retrieved LUT. If the requested group, tag or buffer (sequence item) doesn't exist, or if the tag's type is not a sequence (SQ), then a null pointer is returned, otherwise a pointer to the retrieved LUT is returned </dd></dl>

</div>
</div>
<a class="anchor" id="aa9ea638e3dcd1ba46e9a75f2f82330c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1image.html">image</a> &gt; puntoexe::imebra::dataSet::getModalityImage </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>frameNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an image from the dataset and apply the modality transform if it is specified in the dataset. </p>
<p>If the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a> does not contain any modality transform then returns the same image returned by <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a67b350715dd0d0fb03922fcf89dcf8c8" title="Retrieve an image from the dataset. ">getImage()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameNumber</td><td>The frame number to retrieve. The first frame's id is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the retrieved image to which the modality transform has been applied </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dicom2jpeg_2dicom2jpeg_8cpp-example.html#a22">dicom2jpeg/dicom2jpeg.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae28244ca8a0c3c66acd8dcaa135198f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html">dataSet</a> &gt; puntoexe::imebra::dataSet::getSequenceItem </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>itemId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a data set embedded into a sequence tag. </p>
<p>Sequence tags store several binary data which can be individually parsed as a normal dicom file (without the preamble of 128 bytes and the DICM signature).</p>
<p>When using sequences an application can store several nested dicom structures.</p>
<p>This function parse a single item of a sequence tag and return a data set object (represented by a this class) which stores the retrieved tags.</p>
<p>If the requested tag's type is not a sequence or the requested item in the sequence is missed, then a null pointer will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the sequence tag to be parsed belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify which group must be retrieved. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to parse </td></tr>
    <tr><td class="paramname">itemId</td><td>The id of the tag's item to parse (zero based) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the retrieved data set. If the requested group, tag or buffer (sequence item) doesn't exist, or if the tag's type is not a sequence (SQ), then a null pointer is returned, otherwise a pointer to the retrieved dataset is returned </dd></dl>

</div>
</div>
<a class="anchor" id="a57b6f1f619919428dbc8882bc5c15b94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int32_t puntoexe::imebra::dataSet::getSignedLong </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>elementNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the value of the requested tag and return it as a signed long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be read belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to retrieve. A buffer can store several elements: this parameter specifies which element must be retrieved. The first element's number is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag's content, as a signed long </dd></dl>

</div>
</div>
<a class="anchor" id="a98d79f69919fb5b9e7aa754d266e6902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1stream_reader.html">streamReader</a> &gt; puntoexe::imebra::dataSet::getStreamReader </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>bufferId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classpuntoexe_1_1stream_reader.html" title="Represents a stream reader. A stream reader can read data from a stream. Several stream readers can s...">streamReader</a> connected to the specified tag's buffer's memory. </p>
<p>A tag can store several buffers: the application must specify the buffer's id it wants to deal with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>the group to which the tag belongs </td></tr>
    <tr><td class="paramname">order</td><td>if the group is recurring in the file (it appears several times), then use this parameter to specify to which group the tag belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>the tag's id </td></tr>
    <tr><td class="paramname">bufferId</td><td>the buffer's id (zero based) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classpuntoexe_1_1stream_reader.html" title="Represents a stream reader. A stream reader can read data from a stream. Several stream readers can s...">streamReader</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af749aa13e7df06e332b34be2661fd37c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1stream_writer.html">streamWriter</a> &gt; puntoexe::imebra::dataSet::getStreamWriter </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>bufferId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dataType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classpuntoexe_1_1stream_writer.html" title="Use this class to write into a baseStream derived class. ">streamWriter</a> connected to the specified tag's buffer's memory. </p>
<p>A tag can store several buffers, then the application must specify the buffer's id it wants to deal with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>the group to which the tag belongs </td></tr>
    <tr><td class="paramname">order</td><td>if the group is recurring in the file (it appears several times), then use this parameter to specify to which group the tag belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>the tag's id </td></tr>
    <tr><td class="paramname">bufferId</td><td>the buffer's id (zero based) </td></tr>
    <tr><td class="paramname">dataType</td><td>the datatype used to create the buffer if it doesn't exist already </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classpuntoexe_1_1stream_writer.html" title="Use this class to write into a baseStream derived class. ">streamWriter</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a22a19c209f8187e01b67a4921b381988"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string puntoexe::imebra::dataSet::getString </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>elementNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a tag's value as a string. <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#a6a2a5ebf83ff8b350c87b1a0c732d2d6" title="Retrieve a tag&#39;s value as an unicode string. ">getUnicodeString()</a> is preferred over this method. </p>
<p>Read the value of the requested tag and return it as a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be read belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to retrieve. A buffer can store several elements: this parameter specifies which element must be retrieved. The first element's number is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag's content, as a string </dd></dl>

</div>
</div>
<a class="anchor" id="a46ebeb89a79313fb0969ea0b7ffdff5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data.html">data</a> &gt; puntoexe::imebra::dataSet::getTag </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCreate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a tag object. </p>
<p>Tag object is represented by the <a class="el" href="classpuntoexe_1_1imebra_1_1data.html">data</a> class.</p>
<p>If the tag doesn't exist and the parameter bCreate is set to false, then the function returns a null pointer. If the tag doesn't exist and the parameter bCreate is set to true, then an empty tag will be created and inserted into the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag belongs. </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify which group must be retrieved. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero. </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve. </td></tr>
    <tr><td class="paramname">bCreate</td><td>When bCreate is set to true and the requested tag doesn't exist, then a new one is created and inserted into the dataset. When bCreate is set to false and the requested tag doesn't exist, then a null pointer is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the retrieved tag. If the requested tag doesn't exist then the returned value depend on the value of the bCreate parameter: when bCreate is false then a value of zero is returned, otherwise a pointer to the just created tag is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a2a5ebf83ff8b350c87b1a0c732d2d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring puntoexe::imebra::dataSet::getUnicodeString </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>elementNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a tag's value as an unicode string. </p>
<p>Read the value of the requested tag and return it as an unicode string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be read belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to retrieve. A buffer can store several elements: this parameter specifies which element must be retrieved. The first element's number is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag's content, as an unicode string </dd></dl>

</div>
</div>
<a class="anchor" id="aa2cfffce28b7b1bf910361baee5f4c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t puntoexe::imebra::dataSet::getUnsignedLong </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>elementNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a tag's value as an unsigned long. </p>
<p>Read the value of the requested tag and return it as an unsigned long.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be read belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to retrieve </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to retrieve. A buffer can store several elements: this parameter specifies which element must be retrieved. The first element's number is 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag's content, as an unsigned long </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dicom2jpeg_2dicom2jpeg_8cpp-example.html#a34">dicom2jpeg/dicom2jpeg.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa3a31cd71ac089418fcc7bc726c96088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1waveform.html">waveform</a> &gt; puntoexe::imebra::dataSet::getWaveform </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>waveformId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a waveform from the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a>. </p>
<p>Each waveforms is stored in a sequence item; the function retrieves the proper sequence item and connects it to the class waveform which can be used to retrieve the waveform data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveformId</td><td>the zero based index of the waveform to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object waveform that can be used to read the waveform data, or a null pointer if the requested waveform doesn't exist </dd></dl>

</div>
</div>
<a class="anchor" id="a5cb5feb4adb5211654b32de4d7b54e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setDouble </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>elementNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a tag's value as a double. </p>
<p>If the specified tag doesn't exist, then a new one will be created and inserted into the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be write belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to set </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to set. A buffer can store several elements: this parameter specifies which element must be set. The first element's number is 0 </td></tr>
    <tr><td class="paramname">newValue</td><td>the value to be written into the tag </td></tr>
    <tr><td class="paramname">defaultType</td><td>if the specified tag doesn't exist then the function will create a new tag with the data type specified in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaca6bf2aeafd6742dff8a928ab77de9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setGroup </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> &gt;&#160;</td>
          <td class="paramname"><em>pGroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the specified group into the dataset. </p>
<p>A Group object is represented by the <a class="el" href="classpuntoexe_1_1imebra_1_1data_group.html">dataGroup</a> class.</p>
<p>If a group with the same id and order is already present into the data set, then it is removed to leave space to the new group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The id of the group to insert into the data set. </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero. </td></tr>
    <tr><td class="paramname">pGroup</td><td>A pointer to the group to insert into the data set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a219ab785fe7a3abaf172f7190d717e29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setImage </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>frameNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpuntoexe_1_1ptr.html">ptr</a>&lt; <a class="el" href="classpuntoexe_1_1imebra_1_1image.html">image</a> &gt;&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring&#160;</td>
          <td class="paramname"><em>transferSyntax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1codec.html#a2049bc83bc9c0c3345206bf34d4a3be9">codecs::codec::quality</a>&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an image into the data set. </p>
<p>The specified transfer syntax will be used to choose the right codec for the image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameNumber</td><td>The frame number where the image must be stored. The first frame's id is 0. </td></tr>
    <tr><td class="paramname">pImage</td><td>A pointer to the image object to be stored into the data set. </td></tr>
    <tr><td class="paramname">transferSyntax</td><td>the transfer syntax that specifies the codec and the parameters to use for the encoding </td></tr>
    <tr><td class="paramname">quality</td><td>an enumeration that set the compression quality </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4aa4e300d8f39542390d19c79f6e454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setItemOffset </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classpuntoexe_1_1imebra_1_1codecs_1_1dicom_codec.html" title="The Dicom codec. ">codecs::dicomCodec</a> when the dataset is written into a stream. Tells the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a> the position at which it has been written into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the position at which the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a> has been written into the stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03aa341f4e58f5328f3eede5c410afac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setSignedLong </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>elementNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a tag's value as a signed long. </p>
<p>If the specified tag doesn't exist, then a new one will be created and inserted into the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be write belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to set </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to set. A buffer can store several elements: this parameter specifies which element must be set. The first element's number is 0 </td></tr>
    <tr><td class="paramname">newValue</td><td>the value to be written into the tag </td></tr>
    <tr><td class="paramname">defaultType</td><td>if the specified tag doesn't exist then the function will create a new tag with the data type specified in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d555dd2c2873cdd20f8ae295c52bce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setString </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>elementNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a tag's value as a string. <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html#ad6cd9796953fdd8afb1fcca724c922b3" title="Set a tag&#39;s value as an unicode string. ">setUnicodeString()</a> is preferred over this method. </p>
<p>If the specified tag doesn't exist, then a new one will be created and inserted into the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be write belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to set </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to set. A buffer can store several elements: this parameter specifies which element must be set. The first element's number is 0 </td></tr>
    <tr><td class="paramname">newString</td><td>the value to be written into the tag </td></tr>
    <tr><td class="paramname">defaultType</td><td>if the specified tag doesn't exist then the function will create a new tag with the data type specified in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6cd9796953fdd8afb1fcca724c922b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setUnicodeString </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>elementNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring&#160;</td>
          <td class="paramname"><em>newString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a tag's value as an unicode string. </p>
<p>If the specified tag doesn't exist, then a new one will be created and inserted into the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be write belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to set </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to set. A buffer can store several elements: this parameter specifies which element must be set. The first element's number is 0 </td></tr>
    <tr><td class="paramname">newString</td><td>the value to be written into the tag </td></tr>
    <tr><td class="paramname">defaultType</td><td>if the specified tag doesn't exist then the function will create a new tag with the data type specified in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a340038e2662a3ac7a71c01df32d7a297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::setUnsignedLong </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>groupId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>tagId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>elementNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>defaultType</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a tag's value as an unsigned long. </p>
<p>If the specified tag doesn't exist, then a new one will be created and inserted into the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupId</td><td>The group to which the tag to be write belongs </td></tr>
    <tr><td class="paramname">order</td><td>If the group is recurring in the file (it appears several times), then use this parameter to specify to which group the group belongs. This parameter is used to deal with old DICOM files, since the new one should use the sequence items to achieve the same result. It should be set to zero </td></tr>
    <tr><td class="paramname">tagId</td><td>The id of the tag to set </td></tr>
    <tr><td class="paramname">elementNumber</td><td>The element's number to set. A buffer can store several elements: this parameter specifies which element must be set. The first element's number is 0 </td></tr>
    <tr><td class="paramname">newValue</td><td>the value to be written into the tag </td></tr>
    <tr><td class="paramname">defaultType</td><td>if the specified tag doesn't exist then the function will create a new tag with the data type specified in this parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2691c6449b03aa9d7098ae92206cfc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::updateCharsetTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect all the charsets used in the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a>'s tags and then update the content of the tag 0008,0005. </p>
<p>This function is called by the codecs before the dicom stream is saved, therefore the application doesn't need to call the function before saving the stream. </p>

</div>
</div>
<a class="anchor" id="a206defbf8d6e74c6de6d628143b847c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void puntoexe::imebra::dataSet::updateTagsCharset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update all the <a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html" title="A data set is a collection of groups of tags (see dataGroup). ">dataSet</a>'s tags with the charsets specified in the tag 0008,0005. </p>
<p>This function is called by the codecs after the stream has been loaded, therefore the application doesn't need to call the function after the stream has been loaded. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="data_set_8h.html">dataSet.h</a></li>
<li><a class="el" href="data_set_8cpp.html">dataSet.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepuntoexe.html">puntoexe</a></li><li class="navelem"><b>imebra</b></li><li class="navelem"><a class="el" href="classpuntoexe_1_1imebra_1_1data_set.html">dataSet</a></li>
    <li class="footer">Generated on Tue Jan 19 2016 15:32:15 for imebra by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
